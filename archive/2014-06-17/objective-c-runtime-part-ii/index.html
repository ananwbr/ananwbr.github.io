<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/styles.css"><title>Objective-C Runtime: Part II | ANANWBR's</title></head><body><div class="container"><div class="columns page-header"><h1>ANANWBR's</h1></div><div class="columns"><div class="navigation"><nav class="menus-main"><a href="/" class="favicon"><img alt="ANANWBR's" src="/favicon.png"></a><a href="/">Home</a></nav></div></div><div class="columns"><div class="block-body column three-fourths"><article><header><small class="right"></small><h2>Objective-C Runtime: Part II</h2></header><div class="article-meta clearfix"><time class="left">2014-06-17</time><ul class="tags left"><li><a href="/categories/技术/">技术</a></li></ul><ul class="tags right"><li><a href="/tags/iOS/">iOS</a></li></ul></div><div class="markdown-body"><p>在<a href="http://ananwbr.com/blog/2014/06/08/objective-c-runtime-part-i/">上一篇文章</a>中我们已经对Objective-C的runtime有了一定的了解，包括消息发送，一些基本概念，可调用的函数等。今天这篇文章就来讲讲基于runtime有哪些有趣的动态编程技术。</p>
<h3 id="Classes_And_Selectors_From_Strings"><a href="#Classes_And_Selectors_From_Strings" class="headerlink" title="Classes And Selectors From Strings"></a>Classes And Selectors From Strings</h3><p>先来看看最基本的动态用法。我们可以使用Cocoa中的<code>NSClassFromString</code>和<code>NSSelectorFromString</code>函数生成类和selector。如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span> stringclass = NSClassFromString(@<span class="string">"NSString"</span>);</span><br></pre></td></tr></table></figure>
<p>该方法返回了一个类，然后就可以给这个类发送消息啦。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">NSString</span> *myString = [<span class="keyword">stringclass </span><span class="keyword">stringWithString:@"Hello </span>World<span class="string">"];</span></span><br></pre></td></tr></table></figure>
<p>但是有人会问为什么要这么做呢，明明有更简单直接的方法呀。说的没错，但是也存在某些场景会使这些函数变得很有用。比如检查某个类是否存在。如果这个类在运行时不存在那么<code>NSClassFromString</code>就会返回nil。</p>
<p>另外还有种场景是需要根据一些输入条件才能确定某个类或selector做一些操作。比如我们需要根据动物不同的种类显示不同的信息，当然我们可以分别判断类型再调用不同的方法，也可以直接根据种类名直接生成selector调用。后者的好处是便于扩展，以后要增加别的动物类型不需要修改if语句只需要增加相应的方法就行了。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">showAnimal</span>:(id)<span class="tag">animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="tag">if</span>([[animal species] <span class="attribute">isEqualToString</span>:@<span class="string">"Dog"</span>]) &#123;</span><br><span class="line">        <span class="attr_selector">[self showDog:[animal name]</span>];</span><br><span class="line">    &#125; <span class="tag">else</span> <span class="tag">if</span>([[animal species] <span class="attribute">isEqualToString</span>:@<span class="string">"Dog"</span>]) &#123;</span><br><span class="line">        <span class="attr_selector">[self showCat:[animal name]</span>];</span><br><span class="line">    &#125; <span class="tag">else</span> <span class="tag">if</span> ([[animal species] <span class="attribute">isEqualToString</span>:@<span class="string">"Bird"</span>]) &#123;</span><br><span class="line">        <span class="attr_selector">[self showBird:[animal name]</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">showAnimalDynamic</span>:(id)<span class="tag">animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[self performSelector:NSSelectorFromString([NSString stringWithFormat:@"show%@:", [animal species]</span>]) <span class="tag">withObject</span>:<span class="attr_selector">[animal name]</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">showDog</span>:(NSString *)<span class="tag">aDog</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">showCat</span>:(NSString *)<span class="tag">aCat</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">showBird</span>:(NSString *)<span class="tag">aBird</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<!--
### 相关联的对象(Associated Objects)
-->
<h3 id="Method_Swizzling"><a href="#Method_Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>前面我们已经知道了组成方法的两个部分：selector和IMP。前者是一个方法的标识符，后者是指向具体的函数的指针。非常关键的一点是selector和IMP的对应关系是可以被改变的，比如可以把多个secletor映射到同一个IMP。</p>
<p>基于这种特性我们还可以做Method Swizzling。就是将两个方法的具体实现互换。有人可能又会问，为什么要这样做呀。为了回答这个问题我们先来回顾一下在Objective-C中扩展类的两种方法。第一种就是继承（subclassing）。继承允许我们在子类中重写父类中的方法，并且可以在改方法中调用父类的实现。但是这意味着我们必须使用该子类的实例对象。当我们想要继承的是NSArray这样<a href="https://mikeash.com/pyblog/friday-qa-2010-03-12-subclassing-class-clusters.html" target="_blank" rel="external">类簇</a>的时候，就比较麻烦了。第二种是类别（category），这也是我们给一个已有类添加方法的常用方式。但是采用了这种方式而我们又需要覆盖原有的方法，那么在这个方法中是无法调用原来的实现的。</p>
<p>如果我们不想通过子类化重写一个方法又希望能调用原来的实现该怎么办呢，这时候Method Swizzling就要一展身手啦。通常的做法是通过类别给类添加一个方法（当然它也完全可以放在不同的类里），然后通过<code>method_exchangeImplementations()</code>这个runtime函数交换新增方法和原始方法的具体实现。下面我们就通过一个具体的例子来看看这个过程：重写NSMutableArray的<code>addObject:</code>方法使它在每次添加新对象的时候能打印这个对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">Swizzle</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> class], <span class="keyword">@selector</span>(description));</span><br><span class="line">    Method loggingMethod = class_getInstanceMethod([<span class="built_in">NSString</span> class], <span class="keyword">@selector</span>(loggingDescription));</span><br><span class="line">    method_exchangeImplementations(originalMethod, loggingMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)loggingDescription</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"logging description"</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> loggingDescription];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们来分析一下上面的代码。首先需要注意的是我们是在<code>load</code>方法中做了交换的操作。每个类和类别的<code>load</code>方法只有在它们被加载进runtime环境的时候被调用一次，可参考<a href="http://wufawei.com/2013/06/load-initialize/" target="_blank" rel="external">这篇文章</a>。如果我们希望重写的方法在该类的整个生命周期都可用，那么此时就是最好的时机。如果只是想暂时的交换，那放在任何地方都是可以的。</p>
<p>我们还会注意到在<code>logAddObject:</code>中有一个明显的无限递归。这个是Method Swizzling的缺点之一，如果我们忘记了方法的实现交换过那么我们可能会想不明白。记住很重要的一点：在{}之间的代码是IMP，在{}之前的是selector。正常情况下selector和IMP的映射情况就如代码中看到的那样，但是一旦交叉后，这个selector就会映射到另一个IMP。希望下面的图能帮助我们弄清楚一点。</p>
<p><img src="/images/2014/6/class-diagram.png" alt="Method Swizzling"></p>
<h3 id="Dynamic_Subclassing/isa_Swizzling"><a href="#Dynamic_Subclassing/isa_Swizzling" class="headerlink" title="Dynamic Subclassing/isa Swizzling"></a>Dynamic Subclassing/isa Swizzling</h3><p>在上篇文章中我们在讲runtime函数的时候已经知道我们可以从头开始创建一个新的类。虽然这种特性不是很常用到，但一旦用起来还是很有威力的。它允许我们创建一个新的子类，并添加新的功能。</p>
<p>但是这样的子类又有什么用呢。我们需要再次强调一点：Objective-C中的对象有一个叫做isa的变量指向它的类。而这个变量是可以改变的，它可以被修改成指向另一个类而不需要重新创建。这样做虽然不能真正改变对象的示例变量的布局，但我们可以给一个对象增加新的实例变量和方法。下面这一行简单的代码就可以做到改变对象的类了：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">object_setClass</span><span class="params">(myObject, [MySubclass class])</span></span></span><br></pre></td></tr></table></figure>
<p>在Cocoa框架中，<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="external">KVO(Key Value Observing)</a>就是基于这个特性实现的。当我们开始观察一个对象时，Cocoa创建了这个对象的类的子类，然后将这个对象的isa指针指向这个新的子类。可参考<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">Mike Ash的Friday Q&amp;A系列的这篇文章</a>了解更多的细节。</p>
<h3 id="Dynamic_Method_Resolution"><a href="#Dynamic_Method_Resolution" class="headerlink" title="Dynamic Method Resolution"></a>Dynamic Method Resolution</h3><p>前面我们已经讲过了objc_msgSend()背后的工作流程，现在假设一下如果在方法列表中没有找到对应的方法会怎么样呢。事实上runtime是不会轻易放弃的，它还会给有一系列的流程要走。在它放弃之前，我们还有机会做一些不就。</p>
<p>第一个步骤叫做动态方法解析。通常，runtime在解析一个方法的时候会查找到与selector对应的方法并调用。有时候我们希望某个方法在运行时被用到的时候再去创建，因为它在创建之前可能需要先得到runtime的一些信息。在这种情况下我们希望runtime可以在要用到这个方法的时候告诉我们然后我们再创建该方法。</p>
<p>为了达到这样的目的，我们需要重写<code>+resolveInstanceMethod:</code>或<code>+resolveClassMethod:</code>方法。这些方法接收了所需要的方法对应的selector为参数，允许我们给类添加方法。如果我们添加了方法那就得放回<code>YES</code>，这样runtime就不会继续进行下一个步骤。下面是一个简单的例子:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) hasPrefix:<span class="string">@"set"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoSetter, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoGetter, <span class="string">"@@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Cocoa中，CoreData用到了这种技术。</p>
<h3 id="Message_Forwarding"><a href="#Message_Forwarding" class="headerlink" title="Message Forwarding"></a>Message Forwarding</h3><p>如果前一步的方法返回了NO，那么runtime会继续下一步步骤：消息转发。和动态方法解析提供了在运行时动态添加方法的机会不同，消息转发是重定向消息。主要有两种用法，第一种是将消息传递给其他能响应该消息的对象，第二种是将不同的消息导向同一个方法。</p>
<p>消息转发自己也有两步要走。首先，runtime会调用对象的<code>-forwardingTargetForSelector:</code>方法。这个方法效率高，如果我们只是希望将消息传给另一个对象，那使用这个方法就够了。但是如果我们希望在转发消息前对消息做一些修改，那我们就得用到<code>-forwardInvocation:</code>方法了。这种情况下runtime会将消息包装成一个<code>NSInvocation</code>，将它作为该方法的参数。等我们处理完<code>NSInvocation</code>对象，只需简单调用该对象的<code>-invokeWithTarget:</code>的方法，把它传递给新的目标对象。相比而言，第二步的开销会比较大。</p>
<p>在Cocoa种有多处用到了消息转发，最关键的两处是代理(Proxies)和响应链(Responder Chain)。拿响应连来说，Cocoa就是靠着它将事件和action传递给了正确的能处理的对象的。比如当我们按了Cmd-C的时候，会触发一个<code>-copy:</code>的消息。Cocoa首先找到第一响应者(First Responder)，通常是一个激活状态的UI控件，如果它不能响应这个消息，那么这个消息就被转发给下一个响应者(Next Responder)。它会一直沿着响应链传递下去，直到找到能处理的对象，或者走到末端也没有这样的对象那就产生了一个错误。</p>
<p>动态方法解析和消息转发的流程如下图所示：<br><img src="/images/2014/6/message_forwarding.png" alt="消息转发"></p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>终于写完了这一篇，总体而言runtime的部分对我来说还是很有难度，在这里也只是用语言讲了些概念，没有深入到源代码。但知识就是一点点深入的，这两篇文章让我在原来的水品上深入了一步，以后如果要用到更深的内容，我想我还会花时间继续研究的。</p>
<p>原来是想完全按照自己的知识结构来写的，写到后面发现自己功力不够，所以在文章整体结构上就遵循了<a href="http://pilky.me/21/" target="_blank" rel="external">这篇文章</a>，也可以说是在它的基础上假如了自己的一点思考。接下去我会继续挑一些知识点来写，权当是为自己过去这一年在技术学习上所花的时间做一个总结吧。</p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://lianxu.me/2012/11/10-cocoa-objc-newbie-problems/#2" target="_blank" rel="external">10个迷惑新手的Cocoa&amp;Objective-c开发问题</a></li>
<li><a href="http://pilky.me/21/" target="_blank" rel="external">Dynamic Tips &amp; Tricks With Objective-C</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="external">Classes and metaclasses</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">Friday Q&amp;A 2009-01-23</a></li>
<li><a href="http://www.amazon.cn/Effective-Objective-C-2-0-52-Specific-Ways-to-Improve-Your-IOS-and-OS-X-Programs-Galloway-Matt/dp/0321917014/ref=sr_1_2?ie=UTF8&amp;qid=1403432239&amp;sr=8-2&amp;keywords=effective+objective-c+2.0" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
</ol>
</div></article></div><div class="block-sidebar column one-fourth"><div class="widget tags"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul></div><div class="widget archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">六月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">四月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">一月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a><span class="archive-list-count">1</span></li></ul></div><div class="widget text-content"><p>© 2015 ananwbr <br>
Powered by &nbsp;<a href="http://hexo.io">Hexo</a></p></div></div></div></div></body></html>