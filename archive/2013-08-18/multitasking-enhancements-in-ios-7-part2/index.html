<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/styles.css"><title>iOS7多任务增强（2） | ANANWBR's</title></head><body><div class="container"><div class="columns page-header"><h1>ANANWBR's</h1></div><div class="columns"><div class="navigation"><nav class="menus-main"><a href="/" class="favicon"><img alt="ANANWBR's" src="/favicon.png"></a><a href="/">Home</a></nav></div></div><div class="columns"><div class="block-body column three-fourths"><article><header><small class="right"></small><h2>iOS7多任务增强（2）</h2></header><div class="article-meta clearfix"><time class="left">2013-08-18</time><ul class="tags left"><li><a href="/categories/技术/">技术</a></li></ul><ul class="tags right"><li><a href="/tags/iOS/">iOS</a></li></ul></div><div class="markdown-body"><!--
提纲：
* 苹果的广告 
* 改变的东西
* 用户界面的改变，调度的时间（基于系统对用户行为的观察）和时机（对设备资源，硬件的检测）
* 新增的东西
-->
<p>最近写作的热情高涨，真是个好现象。一直觉得能坚持写博客的人都很了不起。有时候偶然进到一个人的博客，发现那个人已经连续写了五六年了，就会很想从头开始翻。明明是不认识的人，却莫名很有好感。真希望自己也能积累很多文字，如果能给人带来一点正面的能量，那我也会感觉更加幸福。</p>
<p>如果每天都写一篇文章的话，这样的篇头语也算是日记了~</p>
<p>写前一篇的文章的时候是想写新特性的，结果只讲完了预备知识。现在终于进入正题啦。</p>
<h2 id="iOS7_u591A_u4EFB_u52A1_u589E_u5F3A"><a href="#iOS7_u591A_u4EFB_u52A1_u589E_u5F3A" class="headerlink" title="iOS7多任务增强"></a>iOS7多任务增强</h2><p>先来看看苹果官网是怎么介绍多任务增强的吧。</p>
<p><img src="/images/2013/8/multitasking_introduction.png" alt="官网介绍"></p>
<p>从图中我们可以感受到的最直观的变化是多任务管理界面（也可以叫它应用切换器，洋名“App Switcher”）。还是双击Home键，就可唤出该界面。现在不仅能看到后台应用的图标，还能看到每个应用的预览。（作为开发者需要注意隐藏一些敏感信息）如果想终止某个应用，只要在这个应用的预览图上往上一滑就行了。比起长按再删除，那是方便了太多了。</p>
<p>另外，从图片的文案中我们也可以得出一个关键字：<strong>智能</strong>。可以从两方面来解读这个词：</p>
<ul>
<li>调度的时间：系统会跟踪用户行为，比如启动应用的时间和频率，得出用户的使用规律。比如每天7点我一起床就会打开微博应用，系统经过一段时间的观察之后知道了我的使用规律，它就会在7点前让应用去更新内容，这样我一睁开眼打开应用不用刷新就能看到一夜积累的微博啦。（玩微博好几年了现在还挺控~）</li>
<li>调度的时机：系统也会检查当前的设备情况，比如设备是否激活，网络和电量情况，来智能分配每个应用的获取频率和时间。举个例子，当网络情况良好时，就是获取信息的良机。它还能协调多个应用的更新，所以有网络时，多个应用都可以同时收益。</li>
</ul>
<p>总得来说，不管是UI设计还是用户体验都有不小的提升。</p>
<!--
Translated by Tinyfool:http://tiny4cocoa.com/thread/show/88/

下面，让我们聊聊多任务。
iOS 7构建在有着工业级强度的OS X的坚实基础上。
它包含了大量的功能强大的多任务处理能力。
但是我们把这些能力暴露给App的时候，必须非常小心谨慎，
因为我们想提供更长的使用时间。
在iOS 4我们给某些特定类型的App提供了多任务处理能力，
例如，后台播放音乐的App，接收VOIP来电，允许他们运行在后台。
现在在iOS 7我们高兴的宣布，我们让所有App都有了多任务能力，
同时还保持电池使用时间。
（持久不息的掌声……）
那么，究竟是什么样子呢？
好，设想有一个App你整天都持续在使用，SNS App之类的，
你总是在签到，
iOS 7会监测到你的行为模式，
会给这个App提供频繁的后台活动机会使其信息保持即使的更新。
然后我们看你使用的另外一种App，
也许你只是在早晨、早晨的时候、或者晚上下班以后打开他们，
iOS 7也会注意到他们，
会给这些App在合适的时机后台激活，
这样在你用的时候，他们里面的信息也将是刚刚更新过的。
在这种智能规划之外，
iOS 7还提供了机遇更新机制，
用户每天平均激活iPhone几十次，
这就给App提供了非常好的机会，
系统已经点亮，让App可以在后台更新内容。
它还能根据无线网络情况调节，
你的网络情况很好时，就是获取信息的良机。
它还能协调多个App的更新，
所以你有网络的时候，多个App都可以同时获益。
最后，iOS 7还可以用Push通知激活后台更新，
所以，当你打开一个通知时，App的信息已经更新了。
iOS 7还有非常棒的新界面，在运行的App之间切换，
现在你可以双击Home键进入后台，
在后台App之间滑动，点击就可以进入。
这就是iOS 7的多任务功能。
-->
<p>上面讲的都是作为普通用户就可以体验到的变化。但作为开发者，我们需要知道背后是什么样的机制，有哪些API支撑着这些新特性，了解更多的细节。</p>
<p><strong>首先来看看iOS7对已有的多任务的改变</strong>。WWDC的keynote上列出了以下四点：</p>
<ul>
<li>Background Task Completion</li>
<li>App Switcher（应用切换器）<ul>
<li>新的用户界面突出了应用程序的快照</li>
<li>应该确保用户重新回到应用时界面看起来良好，可参考“State Restoration”这个视频</li>
<li>在应用快照上向上滑移除该应用，在iOS6移除应用表示停止应用运行，在iOS7中还意味着停止应用在后台运行</li>
<li>在后台更新快照</li>
</ul>
</li>
<li>Location Service<ul>
<li>在系统的设置应用中可以配置是否允许某个应用在后台执行任务</li>
<li>系统会尊重App Switcher中的操作，如果用户移除了某个检测位置的应用，当位置变化时，系统不会启动该应用</li>
</ul>
</li>
<li>Newsstand<ul>
<li>在系统的设置应用中可以配置是否允许某个报刊杂志应用在后台更新数据</li>
<li>系统会尊重App Switcher中的操作，如果用户移除了某个报刊杂志应用，当有内容更新时，系统不会启动该应用</li>
<li>继续使用Newsstand API，有</li>
</ul>
</li>
</ul>
<p>下面我们来重点看一下第一点。在<a href="http://ananwbr.com/blog/2013/08/13/multitasking-enhancements-in-ios7/">前一篇文章</a>中我们讲过，用户进入后台时可以通过调用<code>UIApplication</code>类的<code>beginBackgroundTaskWithExpirationHandler:</code>方法向系统请求额外的时间来处理一些诸如上传或下载，完成数据库操作这样的任务。在iOS6中，如果此时用户锁屏了，那么系统会等待任务执行完才进入睡眠状态。而在iOS7中，任务会被暂停，系统会很快进入睡眠状态。直到设备收到事件被唤醒（例如定时事件、推送、位置更新等），后台任务才能继续运行。这就导致了处理过程变成断断续续的，因此如果任务中包含了网络传输的内容推荐使用NSURLSession来处理（即下文中的 Background Transfer Service）。</p>
<p>总结一下后台任务（Background Task Completion）的变化：</p>
<ul>
<li>当设备锁屏时，后台任务不再连累设备保持醒着的状态，而是很快进入睡眠状态</li>
<li>应用还是会有几分钟的时间执行任务，但执行过程不能保证是连续的</li>
</ul>
<p><strong>接下来看看iOS7中有哪些新增的API</strong>。</p>
<ul>
<li>Background Fetch</li>
<li>Remote Notification</li>
<li>Background Transfer Service</li>
</ul>
<h4 id="u540E_u53F0_u83B7_u53D6_uFF08Background_Fetch_uFF09"><a href="#u540E_u53F0_u83B7_u53D6_uFF08Background_Fetch_uFF09" class="headerlink" title="后台获取（Background Fetch）"></a>后台获取（Background Fetch）</h4><!--
it's a periodic way to for your application to get launched into the background to update it's content. It's based on when the user actually user your application so that your fetch opportunities can be as fresh as possible.
This basically just gives your application a chance to launch whenever you send it a push notification crafted in a certain way, it can actually wake up your application in the background with a silent push notification. So that if there's something immediate that needs to happen inside of the application but doesn't need to bother the user, you can do that too.
so this will allow you to enqueue large uploads and downloads for iOS to continue in the background after the user leaves your application and can continue across reboots and just handles all of that for you.
-->
<p>先来回想一下我们平常使用微博的场景。每次打开微博的时候，不管是应用自动更新还是用户手动下拉更新都需要花费一些时间去等待更新完毕。但在iOS7中，新增的后台模式Background Fetch可以让应用在打开之前先更新内容，这样用户进入应用时无需等待就可以看到更新啦。</p>
<p>接下来看看如何让应用程序具备这种功能。</p>
<ol>
<li>在<code>Info.plist</code>中设置<code>UIBackgroundModes</code>的值为<code>fetch</code>。或在Xcode中Capibility下勾选该模式。</li>
<li><p>设置最小的后台获取时间间隔。</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[[UIApplication sharedApplication] setMinimumBackgroundFetchInterval:</span><br><span class="line">UIApplicationBackgroundFetchIntervalMinimum]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>在这里`minimumBackgroundFetchInterval`的值有可以有三种：

* UIApplicationBackgroundFetchIntervalNever：默认为该值，不会去做获取操作
* UIApplicationBackgroundFetchIntervalMinimum：最小时间间隔，在这个间隔内应用不会去做获取操作，但过了这个时间后的任意时候，应用都有可能做获取操作
* 自定义    ，单位为秒
</code></pre><ol>
<li><p>在app delegate中实现’application:performFetchWithCompletionHandler:‘方法，该方法大概有30秒的时间执行任务，比如获取数据并更新界面。当任务完成时，<strong>必须</strong>调用<code>completionHandler</code>并传递结果参数告诉系统这次获取操作的结果。结果参数值包括下面三种：</p>
<ul>
<li>UIBackgroundFetchResultNewData：表示有新数据，系统会生成新的应用快照供App Switcher使用</li>
<li>UIBackgroundFetchResultNoData：无数据</li>
<li>UIBackgroundFetchResultFailed：获取失败</li>
</ul>
</li>
</ol>
<p>另外，在Debug该功能的时候，需要考虑两种情况：</p>
<ul>
<li>应用未启动，此时系统会启动应用并进入后台。Scheme-&gt;Run Section-&gt;Launch Due to a<br>Background Fetch Event</li>
<li>应用处于睡眠状态，此时系统会唤醒应用。Debug-&gt;Simulate Background Fetch</li>
</ul>
<p>总结：系统会根据用户习惯，设备情况等在最佳时机不定期地唤醒或启动注册过Fetch后台模式的应用，使应用在后台下载更新。适用于社交、新闻、天气类需要经常更新的应用。<br><!--Apps that regularly require new content can register with the system and be woken up or launched periodically to download that content in the background. To register, include theUIBackgroundModes key with the fetch value in your app’s Info.plist file and set the minimum time you want between fetch operations using thesetMinimumBackgroundFetchInterval: method. You must also implement the application:performFetchWithCompletionHandler: method in your app delegate to perform any downloads.--></p>
<h4 id="u8FDC_u7A0B_u901A_u77E5_uFF08Remote_Notifications_uFF09"><a href="#u8FDC_u7A0B_u901A_u77E5_uFF08Remote_Notifications_uFF09" class="headerlink" title="远程通知（Remote Notifications）"></a>远程通知（Remote Notifications）</h4><p>在iOS6中，当系统收到远程通知时，它会马上通知用户（Alert，Banner…）。如果需要获取消息相关的内容时，还需要用户点击进入应用后，才开始执行任务。这时候用户需要等待。过程如下图所示：</p>
<p><img src="/images/2013/8/RemoteNotificationiOS6.png" alt="iOS6远程通知"></p>
<p>而在iOS7中，提供了新的后台模式Remote Notification。当应用注册了这种模式，那么当系统收到相应的远程通知时，会先让应用在后台执行任务，任务完成后再通知用户。此时用户点击进入应用后无需等待直接就可以看到内容啦。过程如下图所示：</p>
<p><img src="/images/2013/8/RemoteNotificationiOS7.png" alt="iOS7远程通知"></p>
<p>另外，还有一点值得注意的是，iOS7的远程通知还支持Silent Remote Notification。当用户收到该类型的远程通知时，只会让应用在后台执行任务。任务完成后也不会通知用户。过程如下图所示：</p>
<p><img src="/images/2013/8/SilentRemoteNotification.png" alt="Silent远程通知"></p>
<p>接下来看看如果实现这种后台模式吧。</p>
<ol>
<li>在<code>Info.plist</code>中设置<code>UIBackgroundModes</code>的值为<code>remote-notification</code>。或在Xcode中Capibility下勾选该模式。</li>
<li>在推送通知中设置<code>content-available</code>标记</li>
</ol>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">//remote notification</span><br><span class="line">aps &#123;</span><br><span class="line">    content-available: <span class="number">1</span></span><br><span class="line">    alert: <span class="decorator">&#123;...&#125;</span>      &#125;</span><br><span class="line">  //silent remote notification</span><br><span class="line">aps &#123;</span><br><span class="line">    content-available: <span class="number">1</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在app delegate中实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法，该方法大概有30秒的时间执行任务，比如获取数据并更新界面。当任务完成时，<strong>必须</strong>调用<code>completionHandler</code>并传递结果参数告诉系统这次获取操作的结果。结果参数值参考前文Background Fetch中的说明。</li>
</ol>
<p>关于Silent Remote Notification还有很重要的一点需要知道的是，它的推送速率是受到限制的。因为普通的推送对用户来说是可见的，如果太过频繁让用户觉得很烦人，那么它可以选择关闭通知。但Silent Remote Notification对用户来说是不可见的，也就无法管理。所以iOS和服务器为此做了速率限制。服务器不是阻止你推送通知，而是当速率过快时，会先存储通知，当等到了合适的时候再向用户推送，比如有其他普通的通知要推送时。不过这一切iOS系统和推送服务器会处理，我们只需要知道有这么个机制就可以了。</p>
<p>总结：当有新的内容需要更新时，可以给用户推送通知。当应用收到通知时，可以在后台获取新内容。获取到了之后系统再显示通知（Alert，Banner…）。如果是Silent通知，则不提醒用户。普通的远程通知适用于及时短信，图片短信，视频短信，邮件等应用。Silent远程通知适用于文件同步，“Read it later”等应用。<br><!--
Apps that use push notifications to notify the user that new content is available can now use those notifications to initiate background download operations. To support this mode, include the UIBackgroundModes key with the remote-notification value in your app’s Info.plist file. Your app delegate must also implement theapplication:didReceiveRemoteNotification:fetchCompletionHandler: method.
--></p>
<h4 id="u540E_u53F0_u4F20_u8F93_u670D_u52A1_uFF08Background_Transfer_Service_uFF09"><a href="#u540E_u53F0_u4F20_u8F93_u670D_u52A1_uFF08Background_Transfer_Service_uFF09" class="headerlink" title="后台传输服务（Background Transfer Service）"></a>后台传输服务（Background Transfer Service）</h4><p>在iOS6中，当应用进入后台时可以请求额外的时间进行文件传输的操作。但因为时间有限，不能传输大的文件。iOS7针对这一点做了增强，提供了后台传输服务。这样一来，文件的传输工作由iOS系统来操作，就算应用退出了或设备重启过，文件传输仍然可以进行。因此，文件传输不会受到时间的限制，任何时候应用不管是在前台还是后台都可以提交任务，当任务完成或出错或需要认证时会唤醒应用。</p>
<ol>
<li><p>创建一个后台NSURLSession对象，然后将上传或下载的任务（NSURLSessionTask）交给它，如下图所示：</p>
<p> <img src="/images/2013/8/BackgroundTransferService.png" alt="后台传输服务"></p>
</li>
</ol>
<ol>
<li>在app delegate中实现<code>application:handleEventsForBackgroundURLSession:completionHandler:</code>方法，在该方法中可以根据identifier重新得到NSURLSession对象，然后处理新的内容，并做一些更新界面的操作。当操作完成时，<strong>必须</strong>调用<code>completionHandler</code>，告诉系统界面已经更新可以生成新的快照。</li>
</ol>
<p>还有一点需要知道，后台传输只会在WIFI环境下工作。</p>
<p>总结：后台传输服务允许应用上传或下载大的文件、内容，没有时间限制，就算应用退出或设备重启传输工作仍能继续进行。可以和后台获取和远程通知的后台模式结合使用，适用于照片，视频，文件等内容的上传和下载。</p>
<!--
• Limited time to run in background
• Background completion tasks initiated from the background • Seamless background experience
• Data Protection and Keychain
• Efficient battery life usage
• Cellular data usage
• Removed from the App Switcher
• Background App Refresh Settings
-->
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>终于结束了这篇文章。一来是很久没写文章了，二来以前没怎么写过这类文章，所以写起来还是有点吃力，且速度也慢。本来这周就要做分享的，结果因为没来得及写完，于是向师傅请求再往后推一推，实在是挺不好意思的。祝<br>我下周的分享的能顺利完成吧。</p>
<p>另外，下周要投入更加紧张的新项目了。可能会遇到一些从来没遇到过的问题。可能自己的表现会让人觉得不是很满意。不管怎样，我都会尽自己最大的努力去完成的。</p>
<p>除了工作8小时之外，下周准备开始看Core Text和Text Kit的内容了。期待一下~</p>
</div></article></div><div class="block-sidebar column one-fourth"><div class="widget tags"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul></div><div class="widget archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">六月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">四月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">一月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a><span class="archive-list-count">1</span></li></ul></div><div class="widget text-content"><p>© 2015 ananwbr <br>
Powered by &nbsp;<a href="http://hexo.io">Hexo</a></p></div></div></div></div></body></html>