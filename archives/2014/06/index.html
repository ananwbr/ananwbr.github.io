<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/styles.css"><title>归档：2014 年 6 月 | ANANWBR's</title></head><body><div class="container"><div class="columns page-header"><h1>ANANWBR's</h1></div><div class="columns"><div class="navigation"><nav class="menus-main"><a href="/" class="favicon"><img alt="ANANWBR's" src="/favicon.png"></a><a href="/">Home</a></nav></div></div><div class="columns"><div class="block-body column three-fourths"><div class="archive-title"><strong>归档 2014 年 6 月</strong></div><article><header><h2><a href="/archive/2014-06-25/core-data-overview/">初识Core Data</a></h2></header><div class="article-meta clearfix"><time class="left">2014-06-25</time><ul class="tags left"><li><a href="/categories/技术/">技术</a></li></ul><ul class="tags right"><li><a href="/tags/iOS/">iOS</a></li></ul></div><div class="markdown-body"><p>Core Data一直以来都是我比较怕的一块，每次涉及到这一块内容，我总是底气不足，总觉得它是很复杂的东西我搞不定。从开始实习到现在已经两年时间了，技术水平提高了很多，但单从对这个知识点的掌握程度来看，水平提高基本是停滞的。期间曾多次决定好好研究一下，但中途都放弃了，还会以在心里默念“果然CoreData对我来说难度好高啊”来结尾。这应该是唯一一个让我这么没有耐心和决心的知识点吧。最近做的项目再一次广泛用到了Core Data，终于让我下定决心要把它搞清楚，至少消除害怕的心里。</p>
<p>下面进入正题吧，这篇文章主要是讲一下Core Data的一些基本概念和用法。</p>
<h2 id="Core_Data_u662F_u4EC0_u4E48"><a href="#Core_Data_u662F_u4EC0_u4E48" class="headerlink" title="Core Data是什么"></a>Core Data是什么</h2><p>我们在开发iOS应用的时候，需要把一些数据持久化存储起来，有多种方法可以做到这点，比如属性列表(Property lists)，对象归档(Object archiving)，SQlite数据库，Core Data等。而我们今天要讲的Core Data，它又不仅仅是一种数据持久化的技术。它除了数据的存取功能之外，还能管理被加载到内存中的数据。具体来说，</p>
<ul>
<li>它能管理模型对象所有的更改，给undo和redo操作，以及维护对象之间的相互关系提供了支持。</li>
<li>在任意时刻只在内存中保留所有模型对象的一个子集，这对内存有限的iOS来说是非常重要的。</li>
<li>使用一个模式(schema)来描述模型对象。我们可以在图形界面编辑器种直接定义模型类的主要特征，包括对象之间的关系。也可以很方便的设置默认值以及属性值验证。</li>
<li>提供了对数据模型版本变迁的支持，使得我们很容易升级数据模型版本。<!--
4.Allows you to maintain disjoint sets of edits of your objects. This is useful if you want to, for example, allow the user to make edits in one view that may be discarded without affecting data displayed in another view.
-->
</li>
</ul>
<p>简而言之，Core Data就是一个模式驱动(schema-driven)的对象图管理和数据持久化的框架。</p>
<h2 id="Core_Data_u5806_u6808"><a href="#Core_Data_u5806_u6808" class="headerlink" title="Core Data堆栈"></a>Core Data堆栈</h2><p>Core Data使用了多个组件来完成对象图管理和持久化的工作。这些组件组合到一起就被称为Core Data堆栈了。下面就是一个简单的堆栈的图示：当然在实际应用中，使用的堆栈可能要比这个复杂的多，可能存在多个Managed Object Context</p>
<p><img src="/images/2014/6/Core_Data_Stack.png" alt=" A simple Core Data stack"></p>
<p>可以从图中看出，各组件的层次是很分明的。Managed Object Context负责对象图管理，Persistent Object Store负责持久化，两者之间的沟通需要通过Persistent Store Coordinator协调，另外还有一个Managed Object Model来为数据建模。</p>
<p>接下来我们就来具体了解一下各个组件。</p>
<h3 id="Managed_Objects_and_the_Managed_Object_Context"><a href="#Managed_Objects_and_the_Managed_Object_Context" class="headerlink" title="Managed Objects and the Managed Object Context"></a>Managed Objects and the Managed Object Context</h3><p>Managed Objects和Managed Object Context处于堆栈的顶部，也是通常我们直接会接触的对象。</p>
<p>一个managed object是NSManagedObject或它的子类的一个实例对象。从概念上来讲，它是数据库的表中一条记录的对象化表示，是我们的应用中需要操作的数据，比如人力资源应用中的部门和员工。一个managed object总是和一个managed object context关联。</p>
<p>一个managed object context是NSManagedObjectContext的一个实例对象。它代表了一个对象空间，是managed object生存的地方。它的主要职责就是管理内存中的managed object的生存周期，除此之外，它还负责属性验证，维护对象间关系和undo/redo等。</p>
<p>当我们创建一个新的managed object的时候，我们将它插入到managed context中。我们也可以把数据库中的记录取出来转换成managed object放到context中。对内存中的managed object的任何操作都会被保留，直到将更改提交到持久化存储中。</p>
<p><img src="/images/2014/6/managed_objects.png" alt="Managed objects in a context, and a table in the persistent store"></p>
<h3 id="The_Managed_Object_Model"><a href="#The_Managed_Object_Model" class="headerlink" title="The Managed Object Model"></a>The Managed Object Model</h3><p>一个managed object model是NSManagedObjectModel的一个实例对象。它是对数据库和managed object的描述。一个model是很多entity description对象(NSEntityDescription的实例)的集合。一个entity description描述了一个实体(数据库中的一张表)的名字，对应的NSManagedObject子类的名字，以及它拥有的属性和关系。</p>
<p>下图描述了一个entity description，数据库中的一张表和表中的一条记录对应的一个managed object之间的关系：</p>
<p><img src="/images/2014/6/mageed_object_model.png" alt=" An entity description, a table in the database, and a managed object"></p>
<p>Core Data就是这样使用模型将应用中的managed object映射到数据库中的记录的。需要注意的是如果我们修改了模型，那么Core Data将无法读取使用就得模型持久化存储的数据。这时候就需要用到“数据模型版本变迁”的知识，这里暂不赘述。</p>
<h3 id="Persistent_Store_Coordinator"><a href="#Persistent_Store_Coordinator" class="headerlink" title="Persistent Store Coordinator"></a>Persistent Store Coordinator</h3><p>前面已经说过persistent store coordinator架起了persistent store和managed object context之间的桥梁，在Core Data管理数据的过程发挥了核心作用。</p>
<p>一个persistent store coordinator是NSPersistentStoreCoordinator的一个实例对象。它管理着多个persistent object store。一个persistent object store代表持久化的数据的一个外部存储(文件)。前面我们一直在用数据库来表示外部存储，实际上Core Data也支持其他类型的文件系统。我们甚至也可以实现自定义的文件类型</p>
<p>到目前为止我们只是看了最简单的一个堆栈。在实际应用中，我们可能会遇到更复杂的，比如有多个context，或是多个store，但它们都还是和同一个coordinator连接起来，这时候就更能体现它的核心作用了。</p>
<p><img src="/images/2014/6/complex_stack.png" alt="A complex Core Data stack"></p>
<p>到这里，我们就大致了解完了Core Data堆栈中的各个组件啦，下面是在应用中搭建这个堆栈的实际代码。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSManagedObjectModel</span> *managedObjectModel;  </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSManagedObjectContext</span> *managedObjectContext;  </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="built_in">NSPersistentStoreCoordinator</span> *persistentStoreCoordinator;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//@implementation</span></span><br><span class="line"><span class="preprocessor">#pragma mark - Core Data stack</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSManagedObjectContext</span> *)managedObjectContext</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_managedObjectContext != <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _managedObjectContext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *coordinator = [<span class="keyword">self</span> persistentStoreCoordinator];</span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _managedObjectContext = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</span><br><span class="line">        [_managedObjectContext setPersistentStoreCoordinator:coordinator];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _managedObjectContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSManagedObjectModel</span> *)managedObjectModel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_managedObjectModel != <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _managedObjectModel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSURL</span> *modelURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"ebook"</span> withExtension:<span class="string">@"momd"</span>];</span><br><span class="line">    _managedObjectModel = [[<span class="built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:modelURL];</span><br><span class="line">    <span class="keyword">return</span> _managedObjectModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSPersistentStoreCoordinator</span> *)persistentStoreCoordinator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_persistentStoreCoordinator != <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _persistentStoreCoordinator;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURL</span> *storeURL = [[<span class="keyword">self</span> applicationDocumentsDirectory] URLByAppendingPathComponent:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.sqlite"</span>, _bookName]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    _persistentStoreCoordinator = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class="keyword">self</span> managedObjectModel]];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *options = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                             [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>], <span class="built_in">NSMigratePersistentStoresAutomaticallyOption</span>,</span><br><span class="line">                             [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>], <span class="built_in">NSInferMappingModelAutomaticallyOption</span>, <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![_persistentStoreCoordinator addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:storeURL options:options error:&amp;error])</span><br><span class="line">    &#123;</span><br><span class="line">        DLog(<span class="string">@"Unresolved error %@, %@"</span>, error, [error userInfo]);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSFetchRequest</span></span><br><span class="line">    <span class="keyword">return</span> _persistentStoreCoordinator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Application's Documents directory</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURL</span> *)applicationDocumentsDirectory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomains:<span class="built_in">NSUserDomainMask</span>] lastObject];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>本篇文章主要介绍了Core Data的功能，堆栈以及各组间，帮助我们在概念层面先理清楚它的结构。其实这几天我也看了很多Core Data的资料，还有很多知识点可以写，后面可能还会继续写几篇。对我个人来说，先宏观的学习一个知识点，了解背景，整体结构等，对后续的学习很有帮助。我开头就讲到对Core Data我还是比较怵的，每次用到的时候，都是查看文档使用那几个类和方法，虽然解决了问题但也总觉得心虚。比如前面的那段代码，以前看到就只是一段代码，现在再看的话脑子会浮现堆栈结构图。在进行数据操作的时候也可以理解内在的工作流程，如果遇到更难的问题也能在现在的认知基础上学习更深入的知识啦。</p>
<p>今后的文章主题，不再刻意去找了。当前学习了什么知识点，有哪些收获，就及时记录下来吧。</p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.objc.io/issue-4/core-data-overview.html" target="_blank" rel="external">Core Data Overview</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html" target="_blank" rel="external">Core Data Programming Guide</a></li>
</ol>
</div></article><article><header><h2><a href="/archive/2014-06-23/graduation-anniversary/">写在毕业一周年</a></h2></header><div class="article-meta clearfix"><time class="left">2014-06-23</time><ul class="tags left"><li><a href="/categories/技术/">技术</a></li></ul><ul class="tags right"><li><a href="/tags/总结/">总结</a></li></ul></div><div class="markdown-body"><p>去年的今天，我们毕业了。我是最后一个离开寝室的，和室友一一拥抱告别，看着她们离开，原以为不会有那么多情绪的我，还是哭成了一个傻逼。我知道，这一别，见面就不是那么容易了，其他三人一人留杭，另外两人都回家乡发展了。我不用像她们走的那么远，我只是把所有家当都运到了滨江的一个很小的出租房里。那天房间还没有通网。我一个人出去溜达了一圈，买了碗凉皮当晚饭。现在还是会看到那个凉皮阿姨，每次看到她，我都会想起那天的心情。</p>
<p>不过那时候我以为一年会很久，我想一年时间够我做很多事吧。没想到一转眼就过去了。今天收到邮件说要写年中总结了，不知道是不是要加薪了。我还记得去年年底写的年终总结，那时候显然比现在更有热情，也总结了很多事，和所有初入职场对未来抱有很多憧憬的新人一样，毫无保留地将自己的想法泄于文字中。可是在这工作一周年之际，我的脑子里开始出现很多不同的声音，它们在不停相互撕扯，我甚至需要花费一些心里把它们拉开。</p>
<p>我渴望改变。可是很遗憾，我不是那种仅靠内心驱动就可以勇敢做出改变的人。我需要一个不一样的外部环境来推动我，给我勇气。以前有同学说我长了一张自信的脸。但只有我自己知道这并非事实的全部。我给别人的那些自信，坚定，自律等等印象其实已经是我内心经过无数次的撕扯后才有的结果。比如现在我想换个环境，可是又觉得凭自己的现在的能力办不到。我的第一想法可能是那就先别去做了，再修炼一段时间有了更多的资本再去尝试。在最开始的时候我的确被自己说服了。比如我的大学四年的基调从来不是高昂的。因为在大一刚开始的时候我就因为最好的朋友不在身边的孤单衍生出了不够积极的态度。在别人在各种社团活动中游刃有余的时候，我泡在图书馆告诉自己就把大学当成潜伏期吧。我也差点被自己蒙骗过去了，觉得这是自己有主张，有目标的表现。但现在回头看会觉得，这是给当时自我逃避的我的一种心里安慰吧，把害怕融入新环境，交往新朋友的情绪包装成了自己可以接受的东西。归根到底，那就是一种害怕改变的懦弱。如果大学可以重来，我想用更积极的态度迎接新生活。</p>
<p>好了，不扯大学了，毕竟过去的时光已经永远回不去了。不过毕业后的这一年，倒是可以再回顾一下。</p>
<p>去年的五月份在同学们都定好了单位找好了房子的时候，我还没确定要去上海看看呢还是留在杭州发展。又因为不想太早开始工作所以一直拖延着投简历这事。潜意识里我认为自己只要投出简历就会得到工作的。这样看来我对自己还是挺有信心的，又显然与内心的某些自卑的情绪产生了冲突。后来是迫于23号就要被清扫出校的压力，我投出了唯一的简历。上天也算眷顾我，我被录取了。很多人都劝我再多投几家，有个比较，能做出最好的选择。可是我这个人如果有了一个目标就会变成一根筋，之前实习找单位也是这样。最后我来到了这家公司。</p>
<p>关于这家公司最好的一点是不加班，虽然每天到点了还是会磨蹭十几分钟，但基本上大家都蛮早就走了。一年来只加过一次班，应用赶着提交到App Store，于是在国庆放假的前夕工作到十一点多。回到住的地方已经过了门禁了，把房东阿姨叫醒开门才进入。这样的经历反而成了一段回忆。</p>
<p>之前实习的时候过过苦日子，所以后来变得特别容易满足。现在因为下班时间早，还能干很多自己的事，感觉生活质量提高了不少。我有时间煮饭，运动，学习，做自己的项目了。其实有时间还是其次，最重要的是我不再像实习时那样因为加班每天充满都是负能量。心态变好了，干劲十足。</p>
<p>在工作方面，这一年也参与了很多项目。基本上公司的几个最主要的应用都有我贡献的代码。另外也主导了几个商业项目。我觉得技术学习和积累还是得靠自己，项目经验主要是让我更清楚一个真实项目的推进过程，在这个过程和负责不同部分的同事之间如何交流，对整个项目的进度自己内心也能有一定把握。刚开始工作的时候，我总是有一种战战兢兢的感觉，什么时候该做什么事，哪个问题需要和哪个同事协作解决之类的问题总是让我不够淡定。现在就变得从容多了，知道发测试、提交的时间点后自己也能合理的安排开发进度。一个项目结束后没有收到任务指派先主动问师傅有什么可做的，没有的话自己找点事做比如代码重构或是学习。以前没活干的时候我真的非常不安，觉得自己拿了工资不干点事良心上过不去。现在就觉得如果有活的话管理人员才不会放过我这个资源吧。我在等待安排的同时趁机学点新的知识武装自己。</p>
<p>除了公司的项目，自己业余做的项目也提交到App Store了。虽然年初做的计划是要上3个个人应用的，但是前段时间一直拖延症犯最后能上线我已经感到很欣慰了。只是没有推广又是收费应用没什么下载量。不过接下去我会继续开发新的功能。只要对一个用户产生积极的影响，它的使命也就达成了。</p>
<p>当然这一年还有一些其他的成果和感悟，本来想写在这篇里的，最后发现有些点单独拎出来也能成文，所以就放到后面再来记录吧，这篇就有点虎头蛇尾的感觉了……</p>
<p>总得来说，这一年没有荒废，往后我也会努力做一个快乐的程序员:]</p>
</div></article><article><header><h2><a href="/archive/2014-06-17/objective-c-runtime-part-ii/">Objective-C Runtime: Part II</a></h2></header><div class="article-meta clearfix"><time class="left">2014-06-17</time><ul class="tags left"><li><a href="/categories/技术/">技术</a></li></ul><ul class="tags right"><li><a href="/tags/iOS/">iOS</a></li></ul></div><div class="markdown-body"><p>在<a href="http://ananwbr.com/blog/2014/06/08/objective-c-runtime-part-i/">上一篇文章</a>中我们已经对Objective-C的runtime有了一定的了解，包括消息发送，一些基本概念，可调用的函数等。今天这篇文章就来讲讲基于runtime有哪些有趣的动态编程技术。</p>
<h3 id="Classes_And_Selectors_From_Strings"><a href="#Classes_And_Selectors_From_Strings" class="headerlink" title="Classes And Selectors From Strings"></a>Classes And Selectors From Strings</h3><p>先来看看最基本的动态用法。我们可以使用Cocoa中的<code>NSClassFromString</code>和<code>NSSelectorFromString</code>函数生成类和selector。如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span> stringclass = NSClassFromString(@<span class="string">"NSString"</span>);</span><br></pre></td></tr></table></figure>
<p>该方法返回了一个类，然后就可以给这个类发送消息啦。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="label">NSString</span> *myString = [<span class="keyword">stringclass </span><span class="keyword">stringWithString:@"Hello </span>World<span class="string">"];</span></span><br></pre></td></tr></table></figure>
<p>但是有人会问为什么要这么做呢，明明有更简单直接的方法呀。说的没错，但是也存在某些场景会使这些函数变得很有用。比如检查某个类是否存在。如果这个类在运行时不存在那么<code>NSClassFromString</code>就会返回nil。</p>
<p>另外还有种场景是需要根据一些输入条件才能确定某个类或selector做一些操作。比如我们需要根据动物不同的种类显示不同的信息，当然我们可以分别判断类型再调用不同的方法，也可以直接根据种类名直接生成selector调用。后者的好处是便于扩展，以后要增加别的动物类型不需要修改if语句只需要增加相应的方法就行了。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">showAnimal</span>:(id)<span class="tag">animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="tag">if</span>([[animal species] <span class="attribute">isEqualToString</span>:@<span class="string">"Dog"</span>]) &#123;</span><br><span class="line">        <span class="attr_selector">[self showDog:[animal name]</span>];</span><br><span class="line">    &#125; <span class="tag">else</span> <span class="tag">if</span>([[animal species] <span class="attribute">isEqualToString</span>:@<span class="string">"Dog"</span>]) &#123;</span><br><span class="line">        <span class="attr_selector">[self showCat:[animal name]</span>];</span><br><span class="line">    &#125; <span class="tag">else</span> <span class="tag">if</span> ([[animal species] <span class="attribute">isEqualToString</span>:@<span class="string">"Bird"</span>]) &#123;</span><br><span class="line">        <span class="attr_selector">[self showBird:[animal name]</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">showAnimalDynamic</span>:(id)<span class="tag">animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[self performSelector:NSSelectorFromString([NSString stringWithFormat:@"show%@:", [animal species]</span>]) <span class="tag">withObject</span>:<span class="attr_selector">[animal name]</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">showDog</span>:(NSString *)<span class="tag">aDog</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">showCat</span>:(NSString *)<span class="tag">aCat</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">showBird</span>:(NSString *)<span class="tag">aBird</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<!--
### 相关联的对象(Associated Objects)
-->
<h3 id="Method_Swizzling"><a href="#Method_Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>前面我们已经知道了组成方法的两个部分：selector和IMP。前者是一个方法的标识符，后者是指向具体的函数的指针。非常关键的一点是selector和IMP的对应关系是可以被改变的，比如可以把多个secletor映射到同一个IMP。</p>
<p>基于这种特性我们还可以做Method Swizzling。就是将两个方法的具体实现互换。有人可能又会问，为什么要这样做呀。为了回答这个问题我们先来回顾一下在Objective-C中扩展类的两种方法。第一种就是继承（subclassing）。继承允许我们在子类中重写父类中的方法，并且可以在改方法中调用父类的实现。但是这意味着我们必须使用该子类的实例对象。当我们想要继承的是NSArray这样<a href="https://mikeash.com/pyblog/friday-qa-2010-03-12-subclassing-class-clusters.html" target="_blank" rel="external">类簇</a>的时候，就比较麻烦了。第二种是类别（category），这也是我们给一个已有类添加方法的常用方式。但是采用了这种方式而我们又需要覆盖原有的方法，那么在这个方法中是无法调用原来的实现的。</p>
<p>如果我们不想通过子类化重写一个方法又希望能调用原来的实现该怎么办呢，这时候Method Swizzling就要一展身手啦。通常的做法是通过类别给类添加一个方法（当然它也完全可以放在不同的类里），然后通过<code>method_exchangeImplementations()</code>这个runtime函数交换新增方法和原始方法的具体实现。下面我们就通过一个具体的例子来看看这个过程：重写NSMutableArray的<code>addObject:</code>方法使它在每次添加新对象的时候能打印这个对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">Swizzle</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> class], <span class="keyword">@selector</span>(description));</span><br><span class="line">    Method loggingMethod = class_getInstanceMethod([<span class="built_in">NSString</span> class], <span class="keyword">@selector</span>(loggingDescription));</span><br><span class="line">    method_exchangeImplementations(originalMethod, loggingMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)loggingDescription</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"logging description"</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> loggingDescription];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们来分析一下上面的代码。首先需要注意的是我们是在<code>load</code>方法中做了交换的操作。每个类和类别的<code>load</code>方法只有在它们被加载进runtime环境的时候被调用一次，可参考<a href="http://wufawei.com/2013/06/load-initialize/" target="_blank" rel="external">这篇文章</a>。如果我们希望重写的方法在该类的整个生命周期都可用，那么此时就是最好的时机。如果只是想暂时的交换，那放在任何地方都是可以的。</p>
<p>我们还会注意到在<code>logAddObject:</code>中有一个明显的无限递归。这个是Method Swizzling的缺点之一，如果我们忘记了方法的实现交换过那么我们可能会想不明白。记住很重要的一点：在{}之间的代码是IMP，在{}之前的是selector。正常情况下selector和IMP的映射情况就如代码中看到的那样，但是一旦交叉后，这个selector就会映射到另一个IMP。希望下面的图能帮助我们弄清楚一点。</p>
<p><img src="/images/2014/6/class-diagram.png" alt="Method Swizzling"></p>
<h3 id="Dynamic_Subclassing/isa_Swizzling"><a href="#Dynamic_Subclassing/isa_Swizzling" class="headerlink" title="Dynamic Subclassing/isa Swizzling"></a>Dynamic Subclassing/isa Swizzling</h3><p>在上篇文章中我们在讲runtime函数的时候已经知道我们可以从头开始创建一个新的类。虽然这种特性不是很常用到，但一旦用起来还是很有威力的。它允许我们创建一个新的子类，并添加新的功能。</p>
<p>但是这样的子类又有什么用呢。我们需要再次强调一点：Objective-C中的对象有一个叫做isa的变量指向它的类。而这个变量是可以改变的，它可以被修改成指向另一个类而不需要重新创建。这样做虽然不能真正改变对象的示例变量的布局，但我们可以给一个对象增加新的实例变量和方法。下面这一行简单的代码就可以做到改变对象的类了：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">object_setClass</span><span class="params">(myObject, [MySubclass class])</span></span></span><br></pre></td></tr></table></figure>
<p>在Cocoa框架中，<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="external">KVO(Key Value Observing)</a>就是基于这个特性实现的。当我们开始观察一个对象时，Cocoa创建了这个对象的类的子类，然后将这个对象的isa指针指向这个新的子类。可参考<a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">Mike Ash的Friday Q&amp;A系列的这篇文章</a>了解更多的细节。</p>
<h3 id="Dynamic_Method_Resolution"><a href="#Dynamic_Method_Resolution" class="headerlink" title="Dynamic Method Resolution"></a>Dynamic Method Resolution</h3><p>前面我们已经讲过了objc_msgSend()背后的工作流程，现在假设一下如果在方法列表中没有找到对应的方法会怎么样呢。事实上runtime是不会轻易放弃的，它还会给有一系列的流程要走。在它放弃之前，我们还有机会做一些不就。</p>
<p>第一个步骤叫做动态方法解析。通常，runtime在解析一个方法的时候会查找到与selector对应的方法并调用。有时候我们希望某个方法在运行时被用到的时候再去创建，因为它在创建之前可能需要先得到runtime的一些信息。在这种情况下我们希望runtime可以在要用到这个方法的时候告诉我们然后我们再创建该方法。</p>
<p>为了达到这样的目的，我们需要重写<code>+resolveInstanceMethod:</code>或<code>+resolveClassMethod:</code>方法。这些方法接收了所需要的方法对应的selector为参数，允许我们给类添加方法。如果我们添加了方法那就得放回<code>YES</code>，这样runtime就不会继续进行下一个步骤。下面是一个简单的例子:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) hasPrefix:<span class="string">@"set"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoSetter, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoGetter, <span class="string">"@@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Cocoa中，CoreData用到了这种技术。</p>
<h3 id="Message_Forwarding"><a href="#Message_Forwarding" class="headerlink" title="Message Forwarding"></a>Message Forwarding</h3><p>如果前一步的方法返回了NO，那么runtime会继续下一步步骤：消息转发。和动态方法解析提供了在运行时动态添加方法的机会不同，消息转发是重定向消息。主要有两种用法，第一种是将消息传递给其他能响应该消息的对象，第二种是将不同的消息导向同一个方法。</p>
<p>消息转发自己也有两步要走。首先，runtime会调用对象的<code>-forwardingTargetForSelector:</code>方法。这个方法效率高，如果我们只是希望将消息传给另一个对象，那使用这个方法就够了。但是如果我们希望在转发消息前对消息做一些修改，那我们就得用到<code>-forwardInvocation:</code>方法了。这种情况下runtime会将消息包装成一个<code>NSInvocation</code>，将它作为该方法的参数。等我们处理完<code>NSInvocation</code>对象，只需简单调用该对象的<code>-invokeWithTarget:</code>的方法，把它传递给新的目标对象。相比而言，第二步的开销会比较大。</p>
<p>在Cocoa种有多处用到了消息转发，最关键的两处是代理(Proxies)和响应链(Responder Chain)。拿响应连来说，Cocoa就是靠着它将事件和action传递给了正确的能处理的对象的。比如当我们按了Cmd-C的时候，会触发一个<code>-copy:</code>的消息。Cocoa首先找到第一响应者(First Responder)，通常是一个激活状态的UI控件，如果它不能响应这个消息，那么这个消息就被转发给下一个响应者(Next Responder)。它会一直沿着响应链传递下去，直到找到能处理的对象，或者走到末端也没有这样的对象那就产生了一个错误。</p>
<p>动态方法解析和消息转发的流程如下图所示：<br><img src="/images/2014/6/message_forwarding.png" alt="消息转发"></p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>终于写完了这一篇，总体而言runtime的部分对我来说还是很有难度，在这里也只是用语言讲了些概念，没有深入到源代码。但知识就是一点点深入的，这两篇文章让我在原来的水品上深入了一步，以后如果要用到更深的内容，我想我还会花时间继续研究的。</p>
<p>原来是想完全按照自己的知识结构来写的，写到后面发现自己功力不够，所以在文章整体结构上就遵循了<a href="http://pilky.me/21/" target="_blank" rel="external">这篇文章</a>，也可以说是在它的基础上假如了自己的一点思考。接下去我会继续挑一些知识点来写，权当是为自己过去这一年在技术学习上所花的时间做一个总结吧。</p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://lianxu.me/2012/11/10-cocoa-objc-newbie-problems/#2" target="_blank" rel="external">10个迷惑新手的Cocoa&amp;Objective-c开发问题</a></li>
<li><a href="http://pilky.me/21/" target="_blank" rel="external">Dynamic Tips &amp; Tricks With Objective-C</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="external">Classes and metaclasses</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">Friday Q&amp;A 2009-01-23</a></li>
<li><a href="http://www.amazon.cn/Effective-Objective-C-2-0-52-Specific-Ways-to-Improve-Your-IOS-and-OS-X-Programs-Galloway-Matt/dp/0321917014/ref=sr_1_2?ie=UTF8&amp;qid=1403432239&amp;sr=8-2&amp;keywords=effective+objective-c+2.0" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
</ol>
</div></article><article><header><h2><a href="/archive/2014-06-08/objective-c-runtime-part-i/">Objective-C Runtime: Part I</a></h2></header><div class="article-meta clearfix"><time class="left">2014-06-08</time><ul class="tags left"><li><a href="/categories/技术/">技术</a></li></ul><ul class="tags right"><li><a href="/tags/iOS/">iOS</a></li></ul></div><div class="markdown-body"><!--
    背景
    runtime文件结构
    Messages
    Objects, Classes & Metaclasses
    Methods, Selectors and IMPs
    Other Runtime Functionality
    Associated object
    Classes And Selectors From Strings
    Method Swizzling
    Dynamic Subclassing/isa Swizzling
    Dynamic Method Resolution
    Message Forwarding
    Using Blocks As Method IMPs
    总结
        优缺点
-->
<p>下周要做个组内分享。本来是想着正好iOS8出来了，可以挑个新特性学习一下。结果没想到Apple出了大招，新语言Swift横空出世了。这几天微博上不断出现Swift相关的文章，大牛们果然学习热情和能力都是超越常人。在短时间内弄明白一个新语言还能写出高质量的文章显然是我等无法企及的。不过也很庆幸自己在这个欣欣向荣的领域里，有这么多充满激情的前辈，虽说不能并肩同行但就算在后面跟着他们的脚步也是颇有兴致的。</p>
<p>既然在短时间内没有能力深入学习新的语言和特性，那就还是来讲讲Objective-C runtime了。虽然Swift在未来的某一天会取代Objective-C，但目前看来后者还会是主力开发语言，深入学习依然有价值。</p>
<p>本篇文章就讲讲是什么使得Objective-C具有了动态特性(runtime)，以及对这种动态特性的应用。</p>
<p>##背景</p>
<p>我个人的学习习惯是当要深入学习某一个知识点的时候我需要一个问句作为思维脑图的初始节点。在runtime这块，<a href="http://lianxu.me/2012/11/10-cocoa-objc-newbie-problems/" target="_blank" rel="external">lianxu的这篇文章</a>给我提供了这个问句：如果让你（设计）实现一个计算机语言，你要如何下手？</p>
<p>文中提到了3种不同的层次，以下是一个简单的概括，具体的细节可细读lianxu的文章：</p>
<p>第一种是传统的面向过程的语言，例如C语言。这种语言的编译器在编译的时候将代码里的函数名称转化成一个相对内存地址，把调用这个函数的语句转换成一个jmp跳转指令。一切在编译时就已经确定了。</p>
<p>第二种是面向对象的语言，是在第一种语言基础上做了改进，增加了类的部分，例如C++。增加了类的部分意味着编译器需要多绕个弯，在严格的C编译器上增加一层类处理的机制，把一个函数限制在它处在的class环境里，每次请求一个函数调用，先找到它的对象, 其类型,返回值，参数等等，确定了这些后再jmp跳转到需要的函数。虽然多了灵活性，但仍然是静态语言。</p>
<p>第三种是动态语言，它将第二种的类的实现部分抽象出来，做成一套完整运行阶段的检测环境。这种语言的函数调用在编译期不能确定内存地址，只有到了运行时才能根据runtime环境中的情况做出跳转。Objective-C就是这样的动态语言。</p>
<p>简而言之，Objective-C就是C的超集+runtime。初学者可能只看到了Objective-C在C的基础上增加的一些额外的关键字和语法，但真正使得这个语言如此强大的是它的runtime，虽然小巧，却无比灵活。</p>
<h2 id="The_Runtime"><a href="#The_Runtime" class="headerlink" title="The Runtime"></a>The Runtime</h2><p><strong>在开始深入学习之前，我们需要建立这样一个概念：runtime的核心是消息发送机制。</strong></p>
<h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><!--
When you think of invoking some code, you think of calling a method. In some languages, this allows for the compiler to perform extra optimisations and error checking as it is a direct and clear relationship between what is being called and what is being invoked. With message sending, this distinction is less clear. You don't need to know if an object will respond to a message in order to send it. You send off the message and it might get handled by the object. Or it could be passed along to another object. A message doesn't need to map to a single method, an object can potentially handle several messages that it funnels through to a single method implementation.

In Objective-C, this messaging is handled by the objc_msgSend() runtime function and its cousins. This function takes a target, a selector and a list of arguments. In fact at a conceptual level, the compiler simply converts all your message sends to calls to objc_msgSend(). For example, the following are functionally equivalent:

[array insertObject:foo atIndex:5];
objc_msgSend(array, @selector(insertObject:atIndex:), foo, 5);
-->
<p>当我们想要执行一段代码的时候，我们通常会调用一个方法。在有些语言中，由于调用的方法和实际执行的代码之间是直接、清楚的关系，所以编译器会做一些额外的优化和错误检查。而在基于消息发送机制的语言中，这种关系变得不再那么清晰。当我们给一个对象发送消息的时候，我们不需要知道该对象是否能响应这个消息。消息发送之后，可能会被这个对象处理，也可能会被转给另一个对象。另外，一个消息并不需要映射到一个单一的方法，而一个对象也可以处理映射到同一个方法实现的不同消息。</p>
<p>在Objective-C中，这种消息机制是通过“objc_msgSend()”runtime函数以及其他一组相似的函数来处理的。我们可以看一下这个函数的声明，它需要一个target，一个selector和一个参数列表：</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line">		* <span class="type">Sends</span> a message <span class="keyword">with</span> a simple <span class="keyword">return</span> value to an instance <span class="keyword">of</span> a class.</span><br><span class="line"> * </span><br><span class="line"> * @param self A <span class="type">pointer</span> to the instance <span class="keyword">of</span> the class that <span class="keyword">is</span> to receive the message.</span><br><span class="line"> * @param op <span class="type">The</span> selector <span class="keyword">of</span> the <span class="keyword">method</span> that handles the message.</span><br><span class="line"> * @param ... </span><br><span class="line"> *   A variable argument list containing the arguments to the <span class="keyword">method</span>.</span><br><span class="line"> * </span><br><span class="line"> * @<span class="keyword">return</span> <span class="type">The</span> <span class="keyword">return</span> value <span class="keyword">of</span> the <span class="keyword">method</span>.</span><br><span class="line"> * </span><br><span class="line"> * @note <span class="type">When</span> it encounters a <span class="keyword">method</span> call, the compiler generates a call to one <span class="keyword">of</span> the</span><br><span class="line"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, <span class="keyword">or</span> \c objc_msgSendSuper_stret.</span><br><span class="line"> *  <span class="type">Messages</span> sent to an <span class="keyword">object</span>’s superclass (<span class="keyword">using</span> the \c super keyword) are sent <span class="keyword">using</span> \c objc_msgSendSuper; </span><br><span class="line"> *  other messages are sent <span class="keyword">using</span> \c objc_msgSend. <span class="type">Methods</span> that have data structures <span class="keyword">as</span> <span class="keyword">return</span> values</span><br><span class="line"> *  are sent <span class="keyword">using</span> \c objc_msgSendSuper_stret <span class="keyword">and</span> \c objc_msgSend_stret.</span><br><span class="line"> */	</span><br><span class="line"> <span class="type">OBJC_EXPORT</span> id objc_msgSend(id self, <span class="type">SEL</span> op, ...)</span><br><span class="line">   __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);</span><br></pre></td></tr></table></figure>
<p>其实在概念层面上，编译器只是简单的将所有消息发送转换成了对objc_msgSend()函数的调用。所以，下面两种方式在功能上来讲是一样的：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[array <span class="string">insertObject:</span>foo <span class="string">atIndex:</span><span class="number">5</span>];</span><br><span class="line">objc_msgSend(array, <span class="annotation">@selector</span>(<span class="string">insertObject:</span><span class="string">atIndex:</span>), foo, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>除了能给对象发送消息，还可以给类发送消息。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="title">[anObject dosomething:something]</span><span class="comment">;</span></span><br><span class="line"><span class="title">[AnClass dosomethong:something]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>下面我们就来详解一下上面两条消息中的主角object和Class，看一下Objective-C的对象模型。</p>
<p>###Objects, Classes &amp; Metaclasses<br>&lt;!–<br>In most OOP languages you have the concepts of classes and of objects. Classes are blueprints from which objects are formed. However, in Objective-C, classes are themselves objects, which can respond to messages, which is why you have the distinction between class and instance methods. In concrete terms, an object in Objective-C is a struct, who’s first member is called isa and is a pointer to its class. This is the definition from objc/objc.h</p>
<p>The object’s class is what holds the list of methods it implements, as well as a pointer to the superclass. Now that makes sense for objects, but classes are also objects. This means a class also has an isa variable, so what does it point to? Well this is where the 3rd type comes in: metaclasses. A metaclass is to a class, what a class is to an object, i.e. it holds the list of methods it implements, as well as the super metaclass. To get a more complete understanding of how objects, classes and metaclasses fit together, read this post by Greg Parker which explains them incredibly well.<br>–&gt;<br>在大多数面向对象编程（OOP）语言中都有类（class）和对象（object）的概念。类给对象提供了生成模板。但在Objective-C中，有点不同，类本身也是对象，也可以响应消息，因此也就有了类方法和实例方法的区别。具体而言，Objective-C中的一个对象是一个结构体（struct），它的第一个成员是一个叫isa的指针，指向它的类。我们可以在。bjc/objc.h中看到定义：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">/// Represents an<span class="instruction"> instance </span>of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAI<span class="class">LABILITY;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的类持有该对象的方法列表，也持有一个指向父类的指针。我们也说过类本身也是对象，这意味着类也有一个isa的变量，它又指向哪里呢。这时候第三种类型元类（metaclass）该登场啦。其实元类对于类来说就如类对于对象一样，它持有类的方法列表和一个指向父元类的指针。这三者之间的关系可以参考下图：</p>
<p><img src="/images/2014/6/class-diagram.png" alt="Object,Class和Metaclass之间的关系"></p>
<!--
What about the metaclass? Is it metaclasses all the way down? No. A metaclass is an instance of the root class's metaclass; the root metaclass is itself an instance of the root metaclass. The isa chain ends in a cycle here: instance to class to metaclass to root metaclass to itself. The behavior of metaclass isa pointers rarely matters, since in the real world nobody sends messages to metaclass objects.

More important is the superclass of a metaclass. The metaclass's superclass chain parallels the class's superclass chain, so class methods are inherited in parallel with instance methods. And the root metaclass's superclass is the root class, so each class object responds to the root class's instance methods. In the end, a class object is an instance of (a subclass of) the root class, just like any other object.

Confused? The diagram may help. Remember, when a message is sent to any object, the method lookup starts with that object's isa pointer, then continues up the superclass chain. "Instance methods" are defined by the class, and "class methods" are defined by the metaclass plus the root (non-meta) class.
-->
<p>从上图可以看出，metaclass并不是无限制的传递下去的，isa指针链会在一个循环中终止：instance-&gt;class-&gt;metaclass-&gt;root metaclass-&gt;root metaclass。由于在现实世界中没有人会给元类发送消息，所以它的isa指向哪里并不重要。Objective-C甚至试图隐藏了metaclass的信息，比如<code>[NSObject class]</code>和<code>[NSObject self]</code>返回的结果一样，但正常情况下前者应该返回<code>NSObject-isa</code>指向的元类。</p>
<p>以上只是简单的介绍了Objective-C的对象模型，如果还想深入了解，推荐细读<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="external">Greg Parker的这篇文章</a>，也是上图的出处。</p>
<p>讲完了message左边的target部分，再来看看右边的method部分吧。</p>
<p>###Methods, Selectors and IMPs<br><!--最后要整理一下整个流程--><br>&lt;!–<br>So we know that the runtime sends messages to objects. We also know that an object’s class holds a list of its methods. So how do those messages map to methods and how are methods actually implemented?</p>
<p>The answer to the first question is pretty simple. The method list in a class is essentially a dictionary, where selectors are the keys and IMPs are the values. An IMP is simply a pointer to the method’s implementation in memory. The really important thing though, is that this connection between the selector and the IMP is determined at runtime, not compile time. This allows us to play around with it, as we’ll see later.</p>
<p>The IMP is usually a pointer to a function, where the first argument is of type id and called self, the second argument is of type SEL and is called _cmd and subsequent arguments are the method arguments. This is where the self and _cmd variables are declared when you use them inside a method. Below is an example of a method and a potential IMP for it:</p>
<ul>
<li>(id)doSomethingWithInt:(int)aInt {}<br>id doSomethingWithInt(id self, SEL _cmd, int aInt) {}<br>–&gt;<br>现在我们已经知道runtime会给对象发送消息，也知道一个对象的类持有该对象的方法列表。那么消息是如何映射到方法，方法的具体实现又是什么呢。</li>
</ul>
<p>对第一个小问的答案其实很简单：类持有的方法列表本质上是一个以selector和IMP作为键值对的dictionary。一个IMP是一个指向内存中该方法具体实现的指针。不过真正重要的一点也是我们需要建立的概念是这种selector和IMP之间的对应关系是在运行时才确定的，而不是编译器。这样的特性也给我们提供了施展各种黑魔法的机会，后面我们会讲到更具体的例子。</p>
<p>我们还是再深入地了解一下IMP吧。通常它是一个指向带有特定参数的函数的指针：第一个参数是id类型叫做self，第二个参数是SEL类型叫做_cmd，随后跟着方法的参数。这也是对我们在方法中使用的self和_cmd变量的生命。以下就是一个方法和它可能对应的IMP的例子：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)doSomethingWithInt:(<span class="keyword">int</span>)aInt &#123;&#125;</span><br><span class="line"><span class="keyword">id</span> doSomethingWithInt(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">int</span> aInt) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在了解了各种概念之后，我们来整理一下整个消息发送的流程。</strong><br><!--
Remember, when a message is sent to any object, the method lookup starts with that object's isa pointer, then continues up the superclass chain. "Instance methods" are defined by the class, and "class methods" are defined by the metaclass plus the root (non-meta) class.
--><br>当我们想要调用一段代码时，我们给一个对象发送消息。编译器把这个消息转换成对objc_msgSend()函数的调用。程序运行时，runtime环境根据对象的isa指针找到它的类从而找到方法列表，再根据seloctor得到对应的IMP，最后跳转到该IMP指向的具体实现。如果在isa指向的类中没有找到该方法，那runtime还会沿着该类的父类链查找。同理，给一个类发送消息也是如此。我们要清楚class定义了实例方法，metaclass和root class定义了类方法。</p>
<p>下面的图可以帮助我们更好的理解这个流程。</p>
<p><img src="/images/2014/6/message_sending.png" alt="消息发送流程"></p>
<p>###Other Runtime Functionality</p>
<p>现在我们已经了解了object，class，selector，IMP和消息发送等概念了，可能有人会问，那runtime到底能做什么呢。其实runtime的功能归纳起来就两点：</p>
<ol>
<li>类和对象的创建，修改和内省</li>
<li>消息发送</li>
</ol>
<p>前文中我们已经涉及到消息发送的内容了，但它只是runtime功能很小的一部分。我们可以来看一下objc/runtime.h和objc/message.h头文件，发现所有的函数的函数名都以它所作用的对象为前缀的。下面就来了解一些有哪些前缀以及相关的函数。</p>
<p>####class<br>以class为前缀的函数是用来类修改和内省的。</p>
<p>比如<code>class_addIvar</code>，<code>class_addMethod</code>，<code>class_addProperty</code>，<code>class_addProtocol</code>，<code>class_addProtocol</code>等允许我们给类添加各种结构。</p>
<p><code>class_copyIvarList</code>，<code>class_copyMethodList</code>，<code>class_copyProtocolList</code>和 <code>class_copyPropertyList</code>等用来得到类中各种类型的结构的列表。</p>
<p>而<code>class_getClassMethod</code>，<code>class_getClassVariable</code>，<code>class_getInstanceMethod</code>，<code>class_getInstanceVariable</code>，<code>class_getMethodImplementation</code>和<code>class_getProperty</code>等函数会根据给定的名字返回对应的结构。</p>
<p>除此之外，也有很多更常用的内省函数被封装成Cocoa方法，</p>
<p>比如<code>class_conformsToProtocol</code>，<code>class_respondsToSelector</code>和<code>class_getSuperclass</code>等。甚至还可以用<code>class_createInstance</code>函数创建一个类的实例对象。</p>
<p>####ivar<br>以ivar为前缀的函数用来得到一个示例变量的名字，内存便宜和Objective-C编码类型等信息。</p>
<p>####method<br>以method为前缀的函数大部分是用来内省的，</p>
<p>比如<code>method_getName</code>，<code>method_getImplementation</code>，<code>method_getReturnType</code>等。还有一些是用来对方法进行修改的，比如<code>method_setImplementation</code>和<code>method_exchangeImplementations</code>，对于这两个函数后面还有更深入的学习。</p>
<p>####objc<br>以objc为前缀的函数层次就比较高了。它包括了一组objc_msgSend函数用来处理核心的消息发送公功能。它还有诸如<code>objc_getAssociatedObject</code>，<code>objc_setAssociatedObject</code>和<code>objc_removeAssociatedObjects</code>等函数用来处理相关参考（associated references，后面会再讲到）。由于这类函数处于整个结构的顶部，我们还可以在运行时通过<code>objc_copyProtocolList</code>，<code>objc_getClassList</code>，<code>objc_getProtocol</code>，<code>objc_getClass</code>等得到更高层次的信息。</p>
<p>####object<br>以object为前缀的函数被对象用来修改和内省。我们可以get和set一个对象的示例变量的值。使用<code>object_copy</code>和<code>object_dispose</code>可以复制对象和释放对象的内存。我们还可以得到对象的类，但最有趣的是我们甚至可以使用<code>object_setClass</code>在运行时去改变这个对象的类。后面我们会看到这种用法的威力。</p>
<p>####property<br>属性存储了相当多的数据。以property为前缀的参数除了得到名字外，还能通过<code>property_getAttributes</code>得到诸如属性的返回类型，它是原子或非原子，使用的内存管理方式，自定义的getter和setter的名字，它的实现是否是动态实现的，支持它的示例变量的名字以及它是否是一个若引用等信息。</p>
<p>####protocol<br>协议和类有点像，但比类精简一点，很多方法是一样的。我们可以通过以protocol为前缀的方法得到某个协议的方法，属性和协议列表并检查它是否遵循了其它的协议。</p>
<p>####sel<br>最后还有一些以sel为前缀的函数可以得到selecor的名字，注册一个selector名字以及检查selector是否相等。</p>
<p>##结束语<br>呼~松一口气。第一部分终于讲完啦。原来没有分上下篇，想一气呵成，不过写起来的篇幅超过预想，所以就先停在这吧。</p>
<p>现在我们已经一定程度掌握了Objective-C runtime能做什么，怎么做等内容。下一篇文章会来讲讲基于runtime有哪些有趣的动态编程技术。相信比这一章的理论知识会更有意思吧。</p>
</div></article><div class="archive-pagination"><div class="paginator"><span class="page-number current">1</span></div></div></div><div class="block-sidebar column one-fourth"><div class="widget tags"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul></div><div class="widget archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">六月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08/">八月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">六月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">四月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">三月 2012</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">一月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12/">十二月 2011</a><span class="archive-list-count">1</span></li></ul></div><div class="widget text-content"><p>© 2015 ananwbr <br>
Powered by &nbsp;<a href="http://hexo.io">Hexo</a></p></div></div></div></div></body></html>